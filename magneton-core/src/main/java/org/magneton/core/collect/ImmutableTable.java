/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.magneton.core.collect;

import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Spliterator;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collector;

import javax.annotation.CanIgnoreReturnValue;
import javax.annotation.CheckForNull;
import javax.annotation.DoNotCall;
import javax.annotation.DoNotMock;

import org.magneton.core.base.MoreObjects;
import org.magneton.core.base.Preconditions;

/**
 * A {@link Table} whose contents will never change, with many other important properties
 * detailed at {@link ImmutableCollection}.
 *
 * <p>
 * See the Guava User Guide article on
 * <a href= "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">
 * immutable collections</a>.
 *
 * @author Gregory Kick
 * @since 11.0
 */
@ElementTypesAreNonnullByDefault
public abstract class ImmutableTable<R, C, V> extends org.magneton.core.collect.AbstractTable<R, C, V>
		implements Serializable {

	ImmutableTable() {
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into an
	 * {@code ImmutableTable}. Each input element is mapped to one cell in the returned
	 * table, with the rows, columns, and values generated by applying the specified
	 * functions.
	 *
	 * <p>
	 * The returned {@code Collector} will throw a {@code NullPointerException} at
	 * collection time if the row, column, or value functions return null on any input.
	 *
	 * @since 21.0
	 */
	public static <T extends Object, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
			Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction,
			Function<? super T, ? extends V> valueFunction) {
		return TableCollectors.toImmutableTable(rowFunction, columnFunction, valueFunction);
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into an
	 * {@code ImmutableTable}. Each input element is mapped to one cell in the returned
	 * table, with the rows, columns, and values generated by applying the specified
	 * functions. If multiple inputs are mapped to the same row and column pair, they will
	 * be combined with the specified merging function in encounter order.
	 *
	 * <p>
	 * The returned {@code Collector} will throw a {@code NullPointerException} at
	 * collection time if the row, column, value, or merging functions return null on any
	 * input.
	 *
	 * @since 21.0
	 */
	public static <T extends Object, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
			Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction,
			Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction) {
		return TableCollectors.toImmutableTable(rowFunction, columnFunction, valueFunction, mergeFunction);
	}

	/**
	 * Returns an empty immutable table.
	 *
	 * <p>
	 * <b>Performance note:</b> the instance returned is a singleton.
	 */
	public static <R, C, V> ImmutableTable<R, C, V> of() {
		return (ImmutableTable<R, C, V>) SparseImmutableTable.EMPTY;
	}

	/** Returns an immutable table containing a single cell. */
	public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) {
		return new SingletonImmutableTable<>(rowKey, columnKey, value);
	}

	/**
	 * Returns an immutable copy of the provided table.
	 *
	 * <p>
	 * The {@link Table#cellSet()} iteration order of the provided table determines the
	 * iteration ordering of all views in the returned table. Note that some views of the
	 * original table and the copied table may have different iteration orders. For more
	 * control over the ordering, create a {@link Builder} and call
	 * {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and
	 * {@link Builder#putAll}
	 *
	 * <p>
	 * Despite the method name, this method attempts to avoid actually copying the data
	 * when it is safe to do so. The exact circumstances under which a copy will or will
	 * not be performed are undocumented and subject to change.
	 */
	public static <R, C, V> ImmutableTable<R, C, V> copyOf(Table<? extends R, ? extends C, ? extends V> table) {
		if (table instanceof ImmutableTable) {
			ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;
			return parameterizedTable;
		}
		else {
			return copyOf(table.cellSet());
		}
	}

	static <R, C, V> ImmutableTable<R, C, V> copyOf(
			Iterable<? extends Table.Cell<? extends R, ? extends C, ? extends V>> cells) {
		Builder<R, C, V> builder = ImmutableTable.builder();
		for (Table.Cell<? extends R, ? extends C, ? extends V> cell : cells) {
			builder.put(cell);
		}
		return builder.build();
	}

	/**
	 * Returns a new builder. The generated builder is equivalent to the builder created
	 * by the {@link Builder#Builder() ImmutableTable.Builder()} constructor.
	 */
	public static <R, C, V> Builder<R, C, V> builder() {
		return new Builder<>();
	}

	/**
	 * Verifies that {@code rowKey}, {@code columnKey} and {@code value} are non-null, and
	 * returns a new entry with those values.
	 */
	static <R, C, V> Table.Cell<R, C, V> cellOf(R rowKey, C columnKey, V value) {
		return Tables.immutableCell(Preconditions.checkNotNull(rowKey, "rowKey"),
				Preconditions.checkNotNull(columnKey, "columnKey"), Preconditions.checkNotNull(value, "value"));
	}

	@Override
	public org.magneton.core.collect.ImmutableSet<Table.Cell<R, C, V>> cellSet() {
		return (org.magneton.core.collect.ImmutableSet<Table.Cell<R, C, V>>) super.cellSet();
	}

	@Override
	abstract org.magneton.core.collect.ImmutableSet<Table.Cell<R, C, V>> createCellSet();

	@Override
	final UnmodifiableIterator<Table.Cell<R, C, V>> cellIterator() {
		throw new AssertionError("should never be called");
	}

	@Override
	final Spliterator<Table.Cell<R, C, V>> cellSpliterator() {
		throw new AssertionError("should never be called");
	}

	@Override
	public ImmutableCollection<V> values() {
		return (ImmutableCollection<V>) super.values();
	}

	@Override
	abstract ImmutableCollection<V> createValues();

	@Override
	final Iterator<V> valuesIterator() {
		throw new AssertionError("should never be called");
	}

	/**
	 * {@inheritDoc}
	 * @throws NullPointerException if {@code columnKey} is {@code null}
	 */
	@Override
	public org.magneton.core.collect.ImmutableMap<R, V> column(C columnKey) {
		Preconditions.checkNotNull(columnKey, "columnKey");
		return org.magneton.core.base.MoreObjects.firstNonNull(
				(org.magneton.core.collect.ImmutableMap<R, V>) columnMap().get(columnKey),
				org.magneton.core.collect.ImmutableMap.<R, V>of());
	}

	@Override
	public org.magneton.core.collect.ImmutableSet<C> columnKeySet() {
		return columnMap().keySet();
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>
	 * The value {@code Map<R, V>} instances in the returned map are
	 * {@link org.magneton.core.collect.ImmutableMap} instances as well.
	 */
	@Override
	public abstract org.magneton.core.collect.ImmutableMap<C, Map<R, V>> columnMap();

	/**
	 * {@inheritDoc}
	 * @throws NullPointerException if {@code rowKey} is {@code null}
	 */
	@Override
	public org.magneton.core.collect.ImmutableMap<C, V> row(R rowKey) {
		Preconditions.checkNotNull(rowKey, "rowKey");
		return MoreObjects.firstNonNull((org.magneton.core.collect.ImmutableMap<C, V>) rowMap().get(rowKey),
				org.magneton.core.collect.ImmutableMap.<C, V>of());
	}

	@Override
	public org.magneton.core.collect.ImmutableSet<R> rowKeySet() {
		return rowMap().keySet();
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>
	 * The value {@code Map<C, V>} instances in the returned map are
	 * {@link org.magneton.core.collect.ImmutableMap} instances as well.
	 */
	@Override
	public abstract ImmutableMap<R, Map<C, V>> rowMap();

	@Override
	public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
		return get(rowKey, columnKey) != null;
	}

	@Override
	public boolean containsValue(@CheckForNull Object value) {
		return values().contains(value);
	}

	/**
	 * Guaranteed to throw an exception and leave the table unmodified.
	 * @throws UnsupportedOperationException always
	 * @deprecated Unsupported operation.
	 */
	@Deprecated
	@Override
	@DoNotCall("Always throws UnsupportedOperationException")
	public final void clear() {
		throw new UnsupportedOperationException();
	}

	/**
	 * Guaranteed to throw an exception and leave the table unmodified.
	 * @throws UnsupportedOperationException always
	 * @deprecated Unsupported operation.
	 */
	@CanIgnoreReturnValue
	@Deprecated
	@Override
	@DoNotCall("Always throws UnsupportedOperationException")
	@CheckForNull
	public final V put(R rowKey, C columnKey, V value) {
		throw new UnsupportedOperationException();
	}

	/**
	 * Guaranteed to throw an exception and leave the table unmodified.
	 * @throws UnsupportedOperationException always
	 * @deprecated Unsupported operation.
	 */
	@Deprecated
	@Override
	@DoNotCall("Always throws UnsupportedOperationException")
	public final void putAll(Table<? extends R, ? extends C, ? extends V> table) {
		throw new UnsupportedOperationException();
	}

	/**
	 * Guaranteed to throw an exception and leave the table unmodified.
	 * @throws UnsupportedOperationException always
	 * @deprecated Unsupported operation.
	 */
	@CanIgnoreReturnValue
	@Deprecated
	@Override
	@DoNotCall("Always throws UnsupportedOperationException")
	@CheckForNull
	public final V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
		throw new UnsupportedOperationException();
	}

	/** Creates the common serialized form for this table. */
	abstract SerializedForm createSerializedForm();

	final Object writeReplace() {
		return createSerializedForm();
	}

	/**
	 * A builder for creating immutable table instances, especially
	 * {@code public static final} tables ("constant tables"). Example:
	 *
	 * <pre>{@code
	 * static final ImmutableTable<Integer, Character, String> SPREADSHEET =
	 *     new ImmutableTable.Builder<Integer, Character, String>()
	 *         .put(1, 'A', "foo")
	 *         .put(1, 'B', "bar")
	 *         .put(2, 'A', "baz")
	 *         .buildOrThrow();
	 * }</pre>
	 *
	 * <p>
	 * By default, the order in which cells are added to the builder determines the
	 * iteration ordering of all views in the returned table, with {@link #putAll}
	 * following the {@link Table#cellSet()} iteration order. However, if
	 * {@link #orderRowsBy} or {@link #orderColumnsBy} is called, the views are sorted by
	 * the supplied comparators.
	 *
	 * <p>
	 * For empty or single-cell immutable tables, {@link #of()} and
	 * {@link #of(Object, Object, Object)} are even more convenient.
	 *
	 * <p>
	 * Builder instances can be reused - it is safe to call {@link #buildOrThrow} multiple
	 * times to build multiple tables in series. Each table is a superset of the tables
	 * created before it.
	 *
	 * @since 11.0
	 */
	@DoNotMock
	public static final class Builder<R, C, V> {

		private final List<Table.Cell<R, C, V>> cells = Lists.newArrayList();

		@CheckForNull
		private Comparator<? super R> rowComparator;

		@CheckForNull
		private Comparator<? super C> columnComparator;

		/**
		 * Creates a new builder. The returned builder is equivalent to the builder
		 * generated by {@link ImmutableTable#builder}.
		 */
		public Builder() {
		}

		/** Specifies the ordering of the generated table's rows. */
		@CanIgnoreReturnValue
		public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator) {
			this.rowComparator = Preconditions.checkNotNull(rowComparator, "rowComparator");
			return this;
		}

		/** Specifies the ordering of the generated table's columns. */
		@CanIgnoreReturnValue
		public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator) {
			this.columnComparator = Preconditions.checkNotNull(columnComparator, "columnComparator");
			return this;
		}

		/**
		 * Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in
		 * the built table. Duplicate key pairs are not allowed and will cause
		 * {@link #build} to fail.
		 */
		@CanIgnoreReturnValue
		public Builder<R, C, V> put(R rowKey, C columnKey, V value) {
			cells.add(cellOf(rowKey, columnKey, value));
			return this;
		}

		/**
		 * Adds the given {@code cell} to the table, making it immutable if necessary.
		 * Duplicate key pairs are not allowed and will cause {@link #build} to fail.
		 */
		@CanIgnoreReturnValue
		public Builder<R, C, V> put(Table.Cell<? extends R, ? extends C, ? extends V> cell) {
			if (cell instanceof Tables.ImmutableCell) {
				Preconditions.checkNotNull(cell.getRowKey(), "row");
				Preconditions.checkNotNull(cell.getColumnKey(), "column");
				Preconditions.checkNotNull(cell.getValue(), "value");
				// all supported methods are covariant
				Table.Cell<R, C, V> immutableCell = (Table.Cell<R, C, V>) cell;
				cells.add(immutableCell);
			}
			else {
				put(cell.getRowKey(), cell.getColumnKey(), cell.getValue());
			}
			return this;
		}

		/**
		 * Associates all of the given table's keys and values in the built table.
		 * Duplicate row key column key pairs are not allowed, and will cause
		 * {@link #build} to fail.
		 * @throws NullPointerException if any key or value in {@code table} is null
		 */
		@CanIgnoreReturnValue
		public Builder<R, C, V> putAll(Table<? extends R, ? extends C, ? extends V> table) {
			for (Table.Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet()) {
				put(cell);
			}
			return this;
		}

		@CanIgnoreReturnValue
		Builder<R, C, V> combine(Builder<R, C, V> other) {
			cells.addAll(other.cells);
			return this;
		}

		/**
		 * Returns a newly-created immutable table.
		 *
		 * <p>
		 * Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that
		 * the method will throw an exception if there are duplicate key pairs. The
		 * {@code build()} method will soon be deprecated.
		 * @throws IllegalArgumentException if duplicate key pairs were added
		 */
		public ImmutableTable<R, C, V> build() {
			return buildOrThrow();
		}

		/**
		 * Returns a newly-created immutable table, or throws an exception if duplicate
		 * key pairs were added.
		 * @throws IllegalArgumentException if duplicate key pairs were added
		 * @since 31.0
		 */
		public ImmutableTable<R, C, V> buildOrThrow() {
			int size = cells.size();
			switch (size) {
			case 0:
				return of();
			case 1:
				return new SingletonImmutableTable<>(Iterables.getOnlyElement(cells));
			default:
				return RegularImmutableTable.forCells(cells, rowComparator, columnComparator);
			}
		}

	}

	/**
	 * Serialized type for all ImmutableTable instances. It captures the logical contents
	 * and preserves iteration order of all views.
	 */
	static final class SerializedForm implements Serializable {

		private static final long serialVersionUID = 0;

		private final Object[] rowKeys;

		private final Object[] columnKeys;

		private final Object[] cellValues;

		private final int[] cellRowIndices;

		private final int[] cellColumnIndices;

		private SerializedForm(Object[] rowKeys, Object[] columnKeys, Object[] cellValues, int[] cellRowIndices,
				int[] cellColumnIndices) {
			this.rowKeys = rowKeys;
			this.columnKeys = columnKeys;
			this.cellValues = cellValues;
			this.cellRowIndices = cellRowIndices;
			this.cellColumnIndices = cellColumnIndices;
		}

		static SerializedForm create(ImmutableTable<?, ?, ?> table, int[] cellRowIndices, int[] cellColumnIndices) {
			return new SerializedForm(table.rowKeySet().toArray(), table.columnKeySet().toArray(),
					table.values().toArray(), cellRowIndices, cellColumnIndices);
		}

		Object readResolve() {
			if (cellValues.length == 0) {
				return of();
			}
			if (cellValues.length == 1) {
				return of(rowKeys[0], columnKeys[0], cellValues[0]);
			}
			org.magneton.core.collect.ImmutableList.Builder<Table.Cell<Object, Object, Object>> cellListBuilder = new ImmutableList.Builder<>(
					cellValues.length);
			for (int i = 0; i < cellValues.length; i++) {
				cellListBuilder
						.add(cellOf(rowKeys[cellRowIndices[i]], columnKeys[cellColumnIndices[i]], cellValues[i]));
			}
			return RegularImmutableTable.forOrderedComponents(cellListBuilder.build(),
					org.magneton.core.collect.ImmutableSet.copyOf(rowKeys), ImmutableSet.copyOf(columnKeys));
		}

	}

}
