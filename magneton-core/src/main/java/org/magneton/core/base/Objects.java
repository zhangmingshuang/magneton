/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.magneton.core.base;

import java.util.Arrays;

import javax.annotation.CheckForNull;
import javax.annotation.Nullable;

/**
 * Helper functions that can operate on any {@code Object}.
 *
 * <p>
 * See the Guava User Guide on
 * <a href="https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained">writing
 * {@code Object} methods with {@code Objects}</a>.
 *
 * @author Laurence Gonsalves
 * @since 2.0
 */
@ElementTypesAreNonnullByDefault
public final class Objects extends ExtraObjectsMethodsForWeb {

	private Objects() {
	}

	/**
	 * Determines whether two possibly-null objects are equal. Returns:
	 *
	 * <ul>
	 * <li>{@code true} if {@code a} and {@code b} are both null.
	 * <li>{@code true} if {@code a} and {@code b} are both non-null and they are equal
	 * according to {@link Object#equals(Object)}.
	 * <li>{@code false} in all other situations.
	 * </ul>
	 *
	 * <p>
	 * This assumes that any non-null objects passed to this function conform to the
	 * {@code
	 * equals()} contract.
	 *
	 * <p>
	 * <b>Note for Java 7 and later:</b> This method should be treated as deprecated; use
	 * {@link java.util.Objects#equals} instead.
	 */
	public static boolean equal(@CheckForNull Object a, @CheckForNull Object b) {
		if (a == b) {
			return true;
		}
		if (a == null || b == null) {
			return false;
		}
		if (a.equals(b)) {
			return true;
		}
		if (a.getClass().isArray() && b.getClass().isArray()) {
			return arrayEquals(a, b);
		}
		return false;
	}

	/**
	 * Generates a hash code for multiple values. The hash code is generated by calling
	 * {@link Arrays#hashCode(Object[])}. Note that array arguments to this method, with
	 * the exception of a single Object array, do not get any special handling; their hash
	 * codes are based on identity and not contents.
	 *
	 * <p>
	 * This is useful for implementing {@link Object#hashCode()}. For example, in an
	 * object that has three properties, {@code x}, {@code y}, and {@code z}, one could
	 * write:
	 *
	 * <pre>{@code
	 * public int hashCode() {
	 *   return Objects.hashCode(getX(), getY(), getZ());
	 * }
	 * }</pre>
	 *
	 * <p>
	 * <b>Warning:</b> When a single object is supplied, the returned hash code does not
	 * equal the hash code of that object.
	 *
	 * <p>
	 * <b>Note for Java 7 and later:</b> This method should be treated as deprecated; use
	 * {@link java.util.Objects#hash} instead.
	 */
	public static int hashCode(@CheckForNull @Nullable Object... objects) {
		return Arrays.hashCode(objects);
	}

	public static Object nullable(@Nullable Object obj) {
		return obj == null ? "null" : obj;
	}

	/**
	 * Compare the given arrays with {@code Arrays.equals}, performing an equality check
	 * based on the array elements rather than the array reference.
	 * @param o1 first array to compare
	 * @param o2 second array to compare
	 * @return whether the given objects are equal
	 * @see #nullSafeEquals(Object, Object)
	 * @see java.util.Arrays#equals
	 */
	private static boolean arrayEquals(Object o1, Object o2) {
		if (o1 instanceof Object[] && o2 instanceof Object[]) {
			return Arrays.equals((Object[]) o1, (Object[]) o2);
		}
		if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
			return Arrays.equals((boolean[]) o1, (boolean[]) o2);
		}
		if (o1 instanceof byte[] && o2 instanceof byte[]) {
			return Arrays.equals((byte[]) o1, (byte[]) o2);
		}
		if (o1 instanceof char[] && o2 instanceof char[]) {
			return Arrays.equals((char[]) o1, (char[]) o2);
		}
		if (o1 instanceof double[] && o2 instanceof double[]) {
			return Arrays.equals((double[]) o1, (double[]) o2);
		}
		if (o1 instanceof float[] && o2 instanceof float[]) {
			return Arrays.equals((float[]) o1, (float[]) o2);
		}
		if (o1 instanceof int[] && o2 instanceof int[]) {
			return Arrays.equals((int[]) o1, (int[]) o2);
		}
		if (o1 instanceof long[] && o2 instanceof long[]) {
			return Arrays.equals((long[]) o1, (long[]) o2);
		}
		if (o1 instanceof short[] && o2 instanceof short[]) {
			return Arrays.equals((short[]) o1, (short[]) o2);
		}
		return false;
	}

}
